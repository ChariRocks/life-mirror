<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Life Mirror</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>◈</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Newsreader:ital,opsz,wght@0,6..72,400;0,6..72,500;1,6..72,400&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#faf8f3;-webkit-font-smoothing:antialiased}
    input,textarea,button{font-family:inherit}
    button{cursor:pointer}
    input:focus,textarea:focus{outline:none;border-color:#b5b0a8!important}
    ::selection{background:rgba(53,122,98,.15)}
  </style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel">
const {useState, useEffect, useCallback, useRef} = React;

/* ═══════ CONSTANTS ═══════ */
const AREAS = [
  {id:"wealth", label:"Wealth", icon:"◈"},
  {id:"health", label:"Health", icon:"◉"},
  {id:"relationships", label:"Relationships", icon:"◇"},
  {id:"purpose", label:"Purpose", icon:"△"},
  {id:"selfworth", label:"Self-Worth", icon:"○"},
  {id:"joy", label:"Joy & Play", icon:"☆"}
];
const ALL_AREAS = [{id:"general", label:"General", icon:"◎"}, ...AREAS];

const EGS = [
  {n:1,  key:"joy",           label:"Joy · Appreciation · Empowerment · Freedom · Love", c:"#2d8a5e"},
  {n:2,  key:"passion",       label:"Passion", c:"#339162"},
  {n:3,  key:"enthusiasm",    label:"Enthusiasm · Eagerness · Happiness", c:"#3a9766"},
  {n:4,  key:"expectation",   label:"Positive Expectation · Belief", c:"#41a06c"},
  {n:5,  key:"optimism",      label:"Optimism", c:"#4ba873"},
  {n:6,  key:"hopefulness",   label:"Hopefulness", c:"#57ae7a"},
  {n:7,  key:"contentment",   label:"Contentment", c:"#66b47f"},
  {n:8,  key:"boredom",       label:"Boredom", c:"#7a9e78"},
  {n:9,  key:"pessimism",     label:"Pessimism", c:"#8a9470"},
  {n:10, key:"frustration",   label:"Frustration · Irritation · Impatience", c:"#978a5e"},
  {n:11, key:"overwhelm",     label:"Overwhelm", c:"#9e8040"},
  {n:12, key:"disappointment", label:"Disappointment", c:"#a07638"},
  {n:13, key:"doubt",         label:"Doubt", c:"#9e6c38"},
  {n:14, key:"worry",         label:"Worry", c:"#9a6235"},
  {n:15, key:"blame",         label:"Blame", c:"#955832"},
  {n:16, key:"discouragement", label:"Discouragement", c:"#8e4e30"},
  {n:17, key:"anger",         label:"Anger", c:"#884838"},
  {n:18, key:"revenge",       label:"Revenge", c:"#80403a"},
  {n:19, key:"hatred",        label:"Hatred · Rage", c:"#783a3c"},
  {n:20, key:"jealousy",      label:"Jealousy", c:"#70353e"},
  {n:21, key:"insecurity",    label:"Insecurity · Guilt · Unworthiness", c:"#683040"},
  {n:22, key:"fear",          label:"Fear · Grief · Depression · Powerlessness", c:"#602a42"}
];
const egsC = k => EGS.find(e=>e.key===k)?.c || "#6e7870";
const egsL = k => EGS.find(e=>e.key===k)?.label || "";
const egsN = k => EGS.find(e=>e.key===k)?.n || 0;
const egsShort = k => {const l = egsL(k); return l.split(" · ")[0];};

const REFLECTIONS_SMALL = [
  "That's close. You can feel that from here.",
  "Not a big leap. Just a gentle turn.",
  "Almost there already. Just a nudge.",
];
const REFLECTIONS_MED = [
  "That's real relief from where you're standing.",
  "Reaching for something better — that's the whole practice.",
  "Just by turning toward it, something's already shifting.",
  "You don't have to get there today. Just face that direction.",
];
const REFLECTIONS_BIG = [
  "That's a reach. Start with the next step toward it.",
  "Big gap — but every step upstream counts.",
  "You won't get there in one jump. But the next emotion up? That's doable.",
];

const MQ = "Life is a mirror — when you smile, life smiles back.";
const REMINDERS = [
  "Nothing is more important than that you feel good.",
  "A belief is just a thought you keep thinking.",
  "You can't get it wrong and you never get it done.", MQ,
  "The basis of your life is freedom, the purpose of your life is joy.",
  "What's coming doesn't need to match what's been.",
  "Reach for the thought that feels better.", MQ,
  "From this new place, what genuinely feels possible?",
  "You are the pointer, not the engine.",
  "Care about how you feel — that's your only work.", MQ,
  "Find the sweetest spot you can right now.",
  "A lot of your thoughts are habitual. Some are intentional.",
  "Everything you want is downstream.", MQ,
  "There are always options. Always a comfortable point to reach right now.",
  "You are the creator of your own reality.",
  "If you would feel better, that could be different.", MQ
];

/* ═══════ COACHING PROMPT ═══════ */
const CPROMPT = `You are the coaching engine inside Life Mirror. You help people shift their emotional orientation using Abraham Hicks teachings. You are a feeling-finder — not a therapist, not a meditation teacher, not a life coach.

CRITICAL — READ THIS FIRST:
The example phrases throughout this prompt are DIRECTIONS, not scripts. Never repeat the same phrase twice in one session. Vary your language naturally. If you catch yourself about to say something you already said earlier in the conversation, find a different way to express it. Sound like a real person, not a system running through a checklist.

CORE CONCEPTS:
- THE STICK: Every subject has two ends — lack and desire. Both always present. The desire end is the FULL desire (not incremental). If fear is on lack end, love/freedom might be desire end.
- POINTER NOT ENGINE: Their only job is to orient. The universe handles the rest. Don't pistonize the pistons.
- HABITUAL THOUGHTS: Most thoughts are autopilot. "Always/never/it's just how it is" = habitual expectation. When you hear one, name it casually. Ways to do this (vary — don't repeat the same one): "That's a pretty well-worn groove, huh?" / "You've thought that one a few times before." / "That one's on autopilot." / "Sounds rehearsed — is it actually true or just familiar?" The point is to help them see the thought as a habit, not a fact. Don't pair it with a second teaching sentence every time — sometimes just naming it is enough. Let them respond.
- EXPECTATION: Where wanting and believing meet. Not hope — genuine expectation. The feeling of "yeah, I think that's actually going to happen." A non-resistant thought that gains momentum on its own.
- TIPPING POINT: Below = reducing resistance (softening, putting things down). Above = increasing allowing (pulled forward, desire building). These feel VERY different. Sense which phase. When you feel it shift, name it naturally — don't use the same words each time. Examples: "Something moved just now." / "That feels different than where you started, doesn't it?" / "You're not putting things down anymore — something's pulling." / "Can you feel the difference between that and where we were?" Read the room — sometimes the person names the shift themselves and you just confirm it.
- COMFORT is the compass. Not "positive." Comfortable.
- Don't explain why you feel bad: Building a case for feeling bad practices that expectation. Gently interrupt.
- Feel better FIRST: Things don't change so you can feel better. You feel better, then things change.
- CO-CREATION: Each person finds their own genuine reach. Universe sorts the rest.
- PORTALS: Interest, comfort, distraction, physical soothe — any portal works when stuck.
- OPTIONS: Always options. Always a comfortable point to reach right now.
- TOPIC DRIFT: If the person changes subject mid-session, name it and offer a choice: "Hold on — you just found something real about [topic]. Do you want to stay with that, or does [new topic] feel like where the energy is?" Don't just follow wherever they go.

FINDING RELIEF (Phase 1 — below tipping point):
When someone is in resistance, help them put things down. The goal is to find ANY thought that feels lighter — not positive, just lighter. Don't use the same phrase every time. Natural ways to guide this: "Is there a way to look at this that doesn't feel so heavy?" / "What's the least stressful version of this?" / "If you didn't have to fix it right now, how would you think about it?" / "What would it feel like to just... not worry about this for a minute?" Sometimes just asking "What do you actually want?" cuts straight through. Follow the person's energy — if they find relief, don't keep digging. If they're still stuck, try a different angle. Don't build momentum here. Just soften.

BUILDING MOMENTUM (Phase 2 — above tipping point):
When someone has crossed the tipping point and something's pulling them forward, go with it. Warmer, more forward. Let them feel the pull. Don't over-explain what's happening — they can feel it.

GENUINE POSSIBILITY — THE NATURAL LANDING:
After someone has shifted and LANDED (not while they're still in it), the session's natural endpoint is an expanded sense of what's possible. Their answer could be a feeling, an action, an outcome, or something tiny. The timeframe could be this hour, tonight, this week — wherever their genuine reach lands. A non-resistant thought gains momentum on its own. Ways to get there (vary these): "So from here, what actually feels doable?" / "What feels real from this new place?" / "Now that you're here, what do you think is actually going to happen?" / "What can you see from here that you couldn't before?" But — and this is critical — ONLY ask if the person is naturally looking forward. If they're still in the feeling, skip it entirely. "Stay with that" or "There it is" can be the end of a session. Not every session needs a possibility landing. The shift IS the work.

WHEN THE PERSON IS ALREADY FEELING GOOD — STOP RULE:
If the person says "yes," "absolutely," "I feel it," "that's it," or is DESCRIBING being in a good state (e.g. "I feel joy and ease," "my attention has shifted," "I'm typing from an expanded sense") — YOUR JOB IS DONE. Do not ask one more question. Do not reflect back what they said with a question attached. Just confirm and stop. "Stay with that." / "There it is." / "Now you're getting somewhere." — PERIOD. Full stop. End of response. The most common mistake is asking a question when the person is already where they need to be. When in doubt, say less.

VOICE — THIS IS CRITICAL:
Sound like a sharp, warm friend at a coffee shop who happens to channel infinite intelligence. Think Abraham in the hot seat — direct, occasionally funny, never precious. Use contractions. Short punchy sentences. Casual.

Good examples: "OK so that's the lack end." / "There it is." / "Now feel that." / "So what do you actually want here?" / "You just shifted — feel that?" / "Stay with that." / "That one's been on repeat, huh?"

BAD examples (NEVER say these): "What's stirring in you?" / "Let whatever's present come up" / "Notice that" / "Hold space" / "Sit with that" / "Beautiful awareness" / "Can you feel your body exhale" / "Let your body exhale" / "Honor that feeling" / "That's so valid" / "I'm curious about..." / "Where's your basket?" / "What's the most comfortable thought you can find about that?" (too formulaic — rephrase naturally). These are therapy words, jargon, or scripted phrases. You are NOT a therapist. Don't use concepts the person needs to learn before they can answer. Don't repeat the same question format across a session.

VALIDATION LIMIT: Don't say "beautiful," "perfect," "gorgeous," or "wonderful" more than once per conversation total. Abraham doesn't hand out gold stars. Instead: "There it is" / "Now you're getting somewhere" / "Can you feel the difference?" / just move forward.

LENGTH: 2-3 sentences MAXIMUM per response. If you've written 3 sentences, STOP and ask ONE question. If you catch yourself at 4+ sentences, you're lecturing. Cut it.

STICK MODE: Let them vent. Listen for habitual thoughts. Name them casually. Quick body check. Then: "So what do you actually want?" Help them see the full desire end. Check: below or above tipping?
FOCUS WHEEL MODE: Clean center desire. 12 statements. 1-3 gentle. 4-6 build. After 6 checkpoint — are they still softening or being pulled forward? 7-9 lean in. 10-12 ride. After they've landed, possibility question IF they're naturally looking forward. Otherwise just let them feel it.

NEVER: action steps, diagnose, spiritual bypass, lecture (>3 sentences), stack questions, promise outcomes, rush past lack, water down desire end, confuse stick with scale, build momentum in deep resistance, argue with habitual thoughts, tell someone their thought is wrong, use therapy language, over-validate, follow topic drift without naming it, use jargon the person has to learn, pull someone out of a good feeling to ask a question, repeat the same phrase twice in one session, ask a question when the person is already in a good place.

START: Open casually based on what you know about their area. Examples: "So — [area]. What's going on there?" / "Talk to me about [area]. What's got some weight on it?" / "What's up with [area]?" If no specific area, just: "OK. What's got your attention right now?" Keep it casual and direct.`;

const SUMMARY_PROMPT = "Summarize this coaching session in 3-4 sentences. Focus on: what the person was working through, what shifted (if anything), where they landed emotionally, and what felt genuinely possible to them by the end (if anything). Write in third person past tense. Be specific, not generic. Keep it under 60 words.";

/* ═══════ STORAGE ═══════ */
const LS_KEY = "life_mirror_data";
const LS_PM = "life_mirror_placemats";
const LS_URL = "life_mirror_sheet_url";
const LS_API = "life_mirror_api_key";

const defArea = () => ({emotion:"contentment", focusWheels:[], currentWheel:{center:"",statements:[]}, chats:[]});
const initAreas = () => ALL_AREAS.reduce((a,x) => {a[x.id]=defArea(); return a}, {});

const loadData = () => {
  try {
    const d = localStorage.getItem(LS_KEY);
    const p = d ? JSON.parse(d) : initAreas();
    ALL_AREAS.forEach(a => {
      if (!p[a.id]) p[a.id] = defArea();
      const v = p[a.id];
      if (!v.focusWheels) v.focusWheels = [];
      if (!v.currentWheel) v.currentWheel = {center:"",statements:[]};
      if (!v.chats) v.chats = [];
      if (!v.emotion) v.emotion = "contentment";
    });
    return p;
  } catch { return initAreas(); }
};
const loadPM = () => { try { return JSON.parse(localStorage.getItem(LS_PM)) || []; } catch { return []; } };
const loadUrl = () => { try { return localStorage.getItem(LS_URL) || ""; } catch { return ""; } };
const loadApi = () => { try { return localStorage.getItem(LS_API) || ""; } catch { return ""; } };
const now = () => new Date().toLocaleString();

/* ═══════ SHARED COMPONENTS ═══════ */
const Fade = ({children, delay=0}) => {
  const [v, setV] = useState(false);
  useEffect(() => { const t = setTimeout(() => setV(true), delay); return () => clearTimeout(t); }, [delay]);
  return <div style={{opacity:v?1:0, transform:v?"translateY(0)":"translateY(8px)", transition:"opacity .4s, transform .4s"}}>{children}</div>;
};

const ReminderStrip = () => {
  const [o, setO] = useState(0);
  useEffect(() => { const id = setInterval(() => setO(p => p + 0.5), 30); return () => clearInterval(id); }, []);
  const d = [...REMINDERS, ...REMINDERS];
  return (
    <div style={{overflow:"hidden", padding:"12px 0", borderBottom:"1px solid #eee9e2", background:"#f6f3ee"}}>
      <div style={{display:"flex", gap:40, whiteSpace:"nowrap", transform:`translateX(-${o % (REMINDERS.length * 300)}px)`, willChange:"transform"}}>
        {d.map((r,i) => (
          <span key={i} style={{fontFamily:"'Cormorant Garamond',serif", fontSize:r===MQ?14.5:14, fontStyle:"italic", color:r===MQ?"#357a62":"#7a756e", fontWeight:r===MQ?500:400, letterSpacing:".01em", flexShrink:0}}>
            {r}<span style={{margin:"0 20px", color:"#d0cbc4"}}>·</span>
          </span>
        ))}
      </div>
    </div>
  );
};

/* ═══════ CHAT PANEL ═══════ */
const ChatPanel = ({areaId, areaLabel, areaData, apiKey, onClose, onSave, logToSheet, mirrorFeel, mirrorReach}) => {
  const [msgs, setMsgs] = useState([]);
  const [inp, setInp] = useState("");
  const [loading, setLoading] = useState(false);
  const [started, setStarted] = useState(false);
  const [closing, setClosing] = useState(false);
  const endRef = useRef(null);
  const inpRef = useRef(null);
  const msgsRef = useRef([]);

  useEffect(() => { endRef.current?.scrollIntoView({behavior:"smooth"}); }, [msgs]);
  useEffect(() => { msgsRef.current = msgs; }, [msgs]);

  const ctx = () => {
    let c = `\n\nCONTEXT: Area=${areaLabel}, Area Emotion=${egsShort(areaData.emotion)}`;
    if (mirrorFeel) c += `\nMirror check: Currently putting out ${egsL(mirrorFeel)} (#${egsN(mirrorFeel)})`;
    if (mirrorReach) c += `, reaching for ${egsL(mirrorReach)} (#${egsN(mirrorReach)})`;
    if (areaData.currentWheel.center)
      c += `\nActive Focus Wheel: "${areaData.currentWheel.center}" (${areaData.currentWheel.statements.length} segments)`;
    const pastChats = (areaData.chats || []).slice(-4);
    if (pastChats.length > 0) {
      c += "\n\nPREVIOUS SESSIONS (most recent last):";
      pastChats.forEach(ch => { c += `\n- (${ch.date}): ${ch.summary}`; });
      c += "\n\nUse these summaries to maintain continuity. Reference previous progress naturally if relevant — but don't force it. If they seem to be revisiting an old topic, note it: 'We've been here before. Last time you found...'";
    }
    return c;
  };

  const callApi = async (messages, sys) => {
    try {
      const r = await fetch("https://api.anthropic.com/v1/messages", {
        method:"POST",
        headers:{"Content-Type":"application/json","x-api-key":apiKey,"anthropic-version":"2023-06-01","anthropic-dangerous-direct-browser-access":"true"},
        body: JSON.stringify({model:"claude-sonnet-4-20250514", max_tokens:300, system:sys||CPROMPT+ctx(), messages})
      });
      const d = await r.json();
      return d.content?.map(b => b.text || "").join("") || "";
    } catch { return ""; }
  };

  const send = async (t) => {
    if (!t.trim()) return;
    const nm = [...msgs, {role:"user", content:t.trim()}];
    setMsgs(nm); setInp(""); setLoading(true);
    const reply = await callApi(nm);
    setMsgs(p => [...p, {role:"assistant", content:reply}]);
    setLoading(false);
    setTimeout(() => inpRef.current?.focus(), 100);
  };

  const start = async () => {
    setStarted(true); setLoading(true);
    const opener = areaId === "general"
      ? "I'm opening a session. Start me off."
      : "I'm opening a session on " + areaLabel + ". Start me off.";
    const reply = await callApi([{role:"user", content:opener}]);
    setMsgs([{role:"assistant", content:reply}]);
    setLoading(false);
    setTimeout(() => inpRef.current?.focus(), 100);
  };

  const handleClose = async () => {
    const currentMsgs = msgsRef.current;
    if (currentMsgs.length < 2) { onClose(); return; }
    setClosing(true);
    const convoText = currentMsgs.map(m => (m.role==="user" ? "Person: " : "Coach: ") + m.content).join("\n");
    let summary = "Session completed.";
    try {
      const s = await callApi(
        [{role:"user", content:"Here is a coaching session transcript. " + SUMMARY_PROMPT + "\n\nTRANSCRIPT:\n" + convoText}],
        "You summarize coaching sessions concisely. Follow the instructions exactly."
      );
      if (s && s.length > 10) summary = s;
    } catch {}
    const chatEntry = {date: new Date().toLocaleDateString(), messages: currentMsgs, summary};
    onSave(chatEntry);
    logToSheet("Chat", {content: summary});
    setClosing(false);
    onClose();
  };

  const mb = {
    user: {bg:"#357a62", c:"#fff", br:"14px 14px 4px 14px", border:"none"},
    assistant: {bg:"#fff", c:"#2a2825", br:"14px 14px 14px 4px", border:"1px solid #e8e4dd"}
  };

  return (
    <div style={{position:"fixed",inset:0,background:"rgba(0,0,0,.35)",zIndex:200,display:"flex",justifyContent:"flex-end"}} onClick={e=>{if(e.target===e.currentTarget&&!closing)handleClose()}}>
      <div style={{width:"100%",maxWidth:420,height:"100%",background:"#faf8f3",display:"flex",flexDirection:"column",boxShadow:"-4px 0 24px rgba(0,0,0,.12)"}}>
        <div style={{padding:"16px 18px",borderBottom:"1px solid #e8e4dd",display:"flex",alignItems:"center",justifyContent:"space-between",flexShrink:0}}>
          <div>
            <div style={{fontFamily:"'Cormorant Garamond',serif",fontSize:17,fontWeight:500,color:"#1e1c1a"}}>Work this with me</div>
            <div style={{fontSize:11,color:"#8a857e"}}>{areaLabel} · {egsShort(areaData.emotion)}{(areaData.chats||[]).length>0?` · ${(areaData.chats||[]).length} past`:""}</div>
          </div>
          <button onClick={closing?undefined:handleClose} style={{background:"none",border:"none",fontSize:20,color:closing?"#ccc":"#8a857e",padding:"4px 8px"}}>×</button>
        </div>
        <div style={{flex:1,overflow:"auto",padding:"16px 18px"}}>
          {closing ? (
            <div style={{textAlign:"center",paddingTop:80}}>
              <p style={{fontFamily:"'Cormorant Garamond',serif",fontSize:17,color:"#1e1c1a",marginBottom:8}}>Reflecting on this session…</p>
              <p style={{fontSize:13,color:"#8a857e",fontStyle:"italic"}}>Saving a summary so we can pick up next time.</p>
            </div>
          ) : !started ? (
            <div style={{textAlign:"center",paddingTop:60}}>
              <p style={{fontFamily:"'Cormorant Garamond',serif",fontSize:18,color:"#1e1c1a",marginBottom:8}}>Ready when you are</p>
              <p style={{fontSize:13,color:"#5a5650",lineHeight:1.6,marginBottom:6}}>I can see how {areaLabel.toLowerCase()} feels and what you've been working on.</p>
              {(areaData.chats||[]).length > 0 && <p style={{fontSize:12,color:"#357a62",marginBottom:16}}>{(areaData.chats||[]).length} past session{(areaData.chats||[]).length>1?"s":""} remembered</p>}
              {apiKey ? <button style={S.pri} onClick={start}>Start a session</button> : <p style={{fontSize:12,color:"#8b5c5c"}}>Add your Anthropic API key in Settings first.</p>}
            </div>
          ) : (
            <>
              {msgs.map((m,i) => (
                <div key={i} style={{marginBottom:14,display:"flex",justifyContent:m.role==="user"?"flex-end":"flex-start"}}>
                  <div style={{maxWidth:"85%",padding:"10px 14px",borderRadius:mb[m.role].br,background:mb[m.role].bg,color:mb[m.role].c,border:mb[m.role].border,fontSize:13.5,lineHeight:1.55,fontFamily:"'Newsreader',serif"}}>{m.content}</div>
                </div>
              ))}
              {loading && <div style={{display:"flex",justifyContent:"flex-start",marginBottom:14}}><div style={{padding:"10px 14px",borderRadius:"14px 14px 14px 4px",background:"#fff",border:"1px solid #e8e4dd",fontSize:13,color:"#8a857e",fontStyle:"italic"}}>feeling into this…</div></div>}
              <div ref={endRef}/>
            </>
          )}
        </div>
        {started && !closing && (
          <div style={{padding:"12px 18px",borderTop:"1px solid #e8e4dd",display:"flex",gap:8,flexShrink:0}}>
            <input ref={inpRef} style={{flex:1,padding:"10px 12px",border:"1px solid #ddd8cf",borderRadius:10,fontSize:13,fontFamily:"'Newsreader',serif",background:"#fff",color:"#2a2825"}} value={inp} onChange={e=>setInp(e.target.value)} onKeyDown={e=>{if(e.key==="Enter"&&!loading)send(inp)}} placeholder="Say what's on your mind…" disabled={loading}/>
            <button style={{padding:"10px 16px",border:"none",borderRadius:9,background:"#357a62",color:"#fff",fontSize:13,cursor:"pointer",opacity:loading?.5:1}} onClick={()=>send(inp)} disabled={loading}>→</button>
          </div>
        )}
      </div>
    </div>
  );
};

/* ═══════ MAIN APP ═══════ */
function LifeMirror() {
  const [view, setView] = useState("mirror");
  const [mFeel, setMFeel] = useState(null);
  const [mReach, setMReach] = useState(null);
  const [mStep, setMStep] = useState(1); /* 1=pick current, 2=pick reach, 3=reflection */
  const [areas, setAreas] = useState(loadData);
  const [placemats, setPlacemats] = useState(loadPM);
  const [sel, setSel] = useState("general");
  const [fCInp, setFCInp] = useState("");
  const [fInp, setFInp] = useState("");
  const [showCP, setShowCP] = useState(false);
  const [sheetUrl, setSheetUrl] = useState(loadUrl);
  const [showSettings, setShowSettings] = useState(false);
  const [syncStatus, setSyncStatus] = useState(null);
  const [urlInp, setUrlInp] = useState(loadUrl);
  const [apiKey, setApiKey] = useState(loadApi);
  const [apiKeyInp, setApiKeyInp] = useState(loadApi);
  const [showChat, setShowChat] = useState(false);
  const [pmMine, setPmMine] = useState([]);
  const [pmUni, setPmUni] = useState([]);
  const [pmInp, setPmInp] = useState("");
  const [pmSide, setPmSide] = useState("mine");

  useEffect(() => { try { localStorage.setItem(LS_KEY, JSON.stringify(areas)); } catch {} }, [areas]);
  useEffect(() => { try { localStorage.setItem(LS_PM, JSON.stringify(placemats)); } catch {} }, [placemats]);
  useEffect(() => { try { localStorage.setItem(LS_URL, sheetUrl); } catch {} }, [sheetUrl]);
  useEffect(() => { try { localStorage.setItem(LS_API, apiKey); } catch {} }, [apiKey]);

  const arObj = ALL_AREAS.find(a => a.id === sel) || ALL_AREAS[0];
  const dt = areas[sel] || defArea();
  const upd = useCallback(fn => setAreas(p => ({...p, [sel]: fn(p[sel] || defArea())})), [sel]);
  const go = (v) => { setView(v); window.scrollTo(0,0); };

  /* Sheet sync */
  const postToSheet = useCallback(async payload => {
    if (!sheetUrl) return;
    try {
      await fetch(sheetUrl, {method:"POST", mode:"no-cors", headers:{"Content-Type":"application/json"}, body:JSON.stringify({type:"life_mirror", ...payload})});
      setSyncStatus("ok"); setTimeout(() => setSyncStatus(null), 2000);
    } catch { setSyncStatus("err"); setTimeout(() => setSyncStatus(null), 3000); }
  }, [sheetUrl]);

  const logToSheet = useCallback((t, x={}) => {
    postToSheet({timestamp:now(), area:arObj.label, entryType:t, emotion:egsL(dt.emotion), ...x});
  }, [sel, areas, postToSheet, arObj, dt]);

  const handleChatSave = useCallback((chatEntry) => {
    upd(d => ({...d, chats:[...(d.chats||[]), chatEntry]}));
  }, [upd]);

  /* Focus Wheel */
  const setCtr = () => { if(!fCInp.trim()) return; upd(d=>({...d, currentWheel:{...d.currentWheel, center:fCInp.trim()}})); setFCInp(""); };
  const addFS = () => {
    if (!fInp.trim() || dt.currentWheel.statements.length >= 12) return;
    const nc = dt.currentWheel.statements.length + 1;
    upd(d => ({...d, currentWheel:{...d.currentWheel, statements:[...d.currentWheel.statements, fInp.trim()]}}));
    setFInp("");
    if (nc === 6) setShowCP(true);
  };
  const completeWheel = (another=false) => {
    const w = dt.currentWheel;
    if (!w.center) return;
    const st = w.statements.map((s,i) => `${i+1}. ${s}`).join(" | ");
    logToSheet("Focus Wheel", {sideSource:`${w.statements.length} segments`, dimension:`Center: ${w.center}`, content:st||"(none)"});
    upd(d => ({
      ...d,
      focusWheels: [...d.focusWheels, {...d.currentWheel, date:new Date().toLocaleDateString(), time:new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}],
      currentWheel: {center:"", statements:[]}
    }));
    setShowCP(false);
    if (!another) go("main");
  };
  const resetWheel = () => {
    if (dt.currentWheel.center) {
      upd(d => ({
        ...d,
        focusWheels: [...d.focusWheels, {...d.currentWheel, date:new Date().toLocaleDateString(), time:new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}],
        currentWheel: {center:"", statements:[]}
      }));
      setShowCP(false);
    }
  };

  /* Placemat */
  const addPmItem = () => {
    if (!pmInp.trim()) return;
    if (pmSide === "mine") setPmMine(p => [...p, pmInp.trim()]);
    else setPmUni(p => [...p, pmInp.trim()]);
    setPmInp("");
  };
  const movePmItem = (from, idx) => {
    if (from === "mine") {
      setPmUni(p => [...p, pmMine[idx]]);
      setPmMine(p => p.filter((_,i) => i !== idx));
    } else {
      setPmMine(p => [...p, pmUni[idx]]);
      setPmUni(p => p.filter((_,i) => i !== idx));
    }
  };
  const rmPmItem = (from, idx) => {
    if (from === "mine") setPmMine(p => p.filter((_,i) => i !== idx));
    else setPmUni(p => p.filter((_,i) => i !== idx));
  };
  const savePlacemat = () => {
    if (pmMine.length === 0 && pmUni.length === 0) return;
    const pm = {date:new Date().toLocaleDateString(), time:new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'}), mine:[...pmMine], universe:[...pmUni]};
    setPlacemats(p => [pm, ...p]);
    postToSheet({timestamp:now(), area:"—", entryType:"Placemat", sideSource:`Mine: ${pmMine.length}, Universe: ${pmUni.length}`, dimension:"", content:`Mine: ${pmMine.join("; ")}`, content2:`Universe: ${pmUni.join("; ")}`, content3:"", emotion:"", tilt:""});
    setPmMine([]); setPmUni([]); setPmInp("");
    go("main");
  };

  /* Mirror check — two-step flow */
  const pickCurrent = k => {
    setMFeel(k);
    /* If already in top 3, skip the reach step */
    if (egsN(k) <= 3) {
      const topPhrases = ["You're already flowing. Stay with that.", "That's alignment. Now let's work with it.", "Nothing to reach for — you're there. Let's go."];
      setReflection(topPhrases[Math.floor(Math.random() * topPhrases.length)]);
      postToSheet({timestamp:now(), area:"—", entryType:"Mirror Check", emotion:egsL(k), sideSource:"—", dimension:`${egsN(k)}`, content:"Already aligned", content2:"", content3:"", tilt:""});
      setMStep(3);
      setMReach(null);
    } else {
      setMStep(2);
    }
  };
  const pickReach = k => {
    setMReach(k);
    const gap = egsN(mFeel) - egsN(k);
    const pool = gap <= 3 ? REFLECTIONS_SMALL : gap <= 7 ? REFLECTIONS_MED : REFLECTIONS_BIG;
    const phrase = pool[Math.floor(Math.random() * pool.length)];
    setReflection(phrase);
    postToSheet({timestamp:now(), area:"—", entryType:"Mirror Check", emotion:egsL(mFeel), sideSource:egsL(k), dimension:`${egsN(mFeel)} → ${egsN(k)}`, content:phrase, content2:"", content3:"", tilt:""});
    setMStep(3);
  };
  const [reflection, setReflection] = useState("");
  const finishMirror = () => { setMStep(1); go("main"); };

  /* CSV */
  const exportCSV = () => {
    let csv = "Timestamp,Area,Type,Detail,Content\n";
    Object.entries(areas).forEach(([id, data]) => {
      const al = ALL_AREAS.find(a=>a.id===id)?.label||id;
      data.focusWheels.forEach(fw => {
        const st = fw.statements.map((s,i) => `${i+1}. ${s}`).join(" | ");
        csv += `"${fw.date} ${fw.time}","${al}","Focus Wheel","Center: ${fw.center}","${st.replace(/"/g,'""')}"\n`;
      });
      (data.chats||[]).forEach(ch => {
        csv += `"${ch.date}","${al}","Chat","","${(ch.summary||'').replace(/"/g,'""')}"\n`;
      });
    });
    placemats.forEach(pm => {
      csv += `"${pm.date} ${pm.time}","—","Placemat","Mine: ${pm.mine.length} / Universe: ${pm.universe.length}","Mine: ${pm.mine.join('; ')} | Universe: ${pm.universe.join('; ')}"\n`;
    });
    const blob = new Blob([csv], {type:"text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = `life-mirror-${new Date().toISOString().slice(0,10)}.csv`; a.click();
    URL.revokeObjectURL(url);
  };

  /* Count total history for an area */
  const areaCount = (id) => {
    const d = areas[id];
    if (!d) return 0;
    return (d.focusWheels?.length||0) + (d.chats?.length||0);
  };

  /* ═══════ RENDER: SETTINGS ═══════ */
  const renderSettings = () => (
    <div style={{position:"fixed",inset:0,background:"rgba(0,0,0,.3)",zIndex:100,display:"flex",alignItems:"center",justifyContent:"center",padding:20}} onClick={e=>{if(e.target===e.currentTarget)setShowSettings(false)}}>
      <div style={{background:"#faf8f3",borderRadius:16,padding:"28px 24px",maxWidth:440,width:"100%",boxShadow:"0 8px 40px rgba(0,0,0,.15)"}}>
        <h2 style={{fontFamily:"'Cormorant Garamond',serif",fontSize:20,fontWeight:400,margin:"0 0 16px",color:"#1e1c1a"}}>Settings</h2>
        <label style={{fontSize:12,color:"#5a5650",display:"block",marginBottom:4}}>Google Sheets URL</label>
        <input style={{...S.ti,width:"100%",marginBottom:12}} value={urlInp} onChange={e=>setUrlInp(e.target.value)} placeholder="https://script.google.com/macros/s/…/exec"/>
        <label style={{fontSize:12,color:"#5a5650",display:"block",marginBottom:4}}>Anthropic API Key</label>
        <input style={{...S.ti,width:"100%",marginBottom:4}} type="password" value={apiKeyInp} onChange={e=>setApiKeyInp(e.target.value)} placeholder="sk-ant-…"/>
        <p style={{fontSize:10,color:"#8a857e",margin:"0 0 16px"}}>Your key stays in this browser only.</p>
        <div style={{display:"flex",gap:8}}>
          <button style={S.pri} onClick={()=>{setSheetUrl(urlInp.trim());setApiKey(apiKeyInp.trim());setShowSettings(false)}}>Save</button>
          <button style={S.sec} onClick={()=>setShowSettings(false)}>Cancel</button>
        </div>
      </div>
    </div>
  );

  /* ═══════ RENDER: MIRROR CHECK ═══════ */
  const renderMirror = () => {
    const ordered = EGS; /* 1 at top, 22 at bottom */
    return (
    <div style={{...S.page, paddingTop:8}}>
      <Fade delay={100}>
        <div style={S.ctr}>
          <h1 style={S.mirrorH}>Before anything else</h1>
          <p style={S.mirrorS}>
            {mStep === 1 && "Right now — not about any specific topic — what are you putting out?"}
            {mStep === 2 && "And where would you like to reach?"}
            {mStep === 3 && reflection}
          </p>
        </div>
      </Fade>

      {mStep === 3 ? (
        <Fade delay={100}>
          <div style={{maxWidth:400, margin:"0 auto", textAlign:"center"}}>
            <div style={{display:"flex", flexDirection:"column", gap:8, marginBottom:28}}>
              <div style={{padding:"12px 16px", borderRadius:10, border:`2px solid ${egsC(mFeel)}`, background:egsC(mFeel)+"12", display:"flex", alignItems:"center", gap:10}}>
                <span style={{fontSize:11, color:"#8a857e", minWidth:22}}>{egsN(mFeel)}</span>
                <span style={{width:9, height:9, borderRadius:"50%", background:egsC(mFeel)}}/>
                <span style={{fontSize:13, color:"#2a2825", fontFamily:"'Newsreader',serif"}}>{egsL(mFeel)}</span>
              </div>
              {mReach && <>
                <div style={{fontSize:12, color:"#8a857e", fontFamily:"'Cormorant Garamond',serif"}}>reaching for ↑</div>
                <div style={{padding:"12px 16px", borderRadius:10, border:`2px solid ${egsC(mReach)}`, background:egsC(mReach)+"12", display:"flex", alignItems:"center", gap:10}}>
                  <span style={{fontSize:11, color:"#8a857e", minWidth:22}}>{egsN(mReach)}</span>
                  <span style={{width:9, height:9, borderRadius:"50%", background:egsC(mReach)}}/>
                  <span style={{fontSize:13, color:"#2a2825", fontFamily:"'Newsreader',serif"}}>{egsL(mReach)}</span>
                </div>
              </>}
            </div>
            <button style={S.pri} onClick={finishMirror}>Now let's work with that →</button>
          </div>
        </Fade>
      ) : (
        <Fade delay={mStep===1?300:100}>
          <div style={{maxWidth:400, margin:"0 auto"}}>
            <div style={{display:"flex", justifyContent:"space-between", marginBottom:10, padding:"0 4px"}}>
              <span style={S.scE}>higher vibration ↑</span>
              <span style={S.scE}>{mStep===1?"lower vibration ↓":"dimmed = below you"}</span>
            </div>
            <div style={{display:"flex", flexDirection:"column", gap:4, maxHeight:"60vh", overflowY:"auto", padding:"4px 0"}}>
              {ordered.map((em) => {
                const isCurrent = mFeel === em.key;
                const isBelow = mStep === 2 && egsN(em.key) > egsN(mFeel);
                const isAtCurrent = mStep === 2 && em.key === mFeel;
                return (
                  <button key={em.key}
                    onClick={() => {
                      if (mStep === 1) pickCurrent(em.key);
                      else if (mStep === 2 && !isBelow && !isAtCurrent) pickReach(em.key);
                    }}
                    disabled={mStep === 2 && (isBelow || isAtCurrent)}
                    style={{
                      display:"flex", alignItems:"center", gap:10, padding:"9px 14px",
                      border: isCurrent && mStep===2 ? `2px solid ${em.c}` : "1px solid #e8e4dd",
                      borderRadius:8,
                      background: isCurrent && mStep===2 ? em.c+"12" : (isBelow || isAtCurrent) ? "#f5f3ef" : "#fff",
                      cursor: (isBelow || isAtCurrent) ? "default" : "pointer",
                      fontFamily:"'Newsreader',serif", fontSize:13,
                      color: (isBelow || isAtCurrent) ? "#c5c0b8" : "#2a2825",
                      transition:"all .2s", width:"100%",
                      opacity: (isBelow) ? 0.4 : 1
                    }}>
                    <span style={{fontSize:10.5, color: (isBelow || isAtCurrent) ? "#d0cbc4" : "#8a857e", minWidth:20, textAlign:"right"}}>{em.n}</span>
                    <span style={{width:8, height:8, borderRadius:"50%", background: (isBelow || isAtCurrent) ? "#d0cbc4" : em.c, flexShrink:0}}/>
                    <span style={{flex:1, textAlign:"left", lineHeight:1.3}}>{em.label}</span>
                    {isAtCurrent && <span style={{fontSize:10, color:em.c}}>← you're here</span>}
                  </button>
                );
              })}
            </div>
          </div>
        </Fade>
      )}

      {mStep === 1 && <Fade delay={550}><p style={S.mirrorHint}>The mirror doesn't judge. It just reflects.</p></Fade>}
    </div>
    );
  };

  /* ═══════ RENDER: MAIN SCREEN ═══════ */
  const renderMain = () => (
    <div style={S.page}>
      <Fade>
        <div style={S.ctr}>
          <h1 style={S.h1}>Life Mirror</h1>
        </div>
      </Fade>

      {/* Area selector */}
      <Fade delay={60}>
        <div style={{marginBottom:20}}>
          <span style={{fontSize:12, color:"#5a5650", display:"block", marginBottom:8}}>What area? <span style={{color:"#b5b0a8"}}>(optional)</span></span>
          <div style={{display:"flex", gap:6, flexWrap:"wrap"}}>
            {ALL_AREAS.map(a => (
              <button key={a.id} onClick={() => setSel(a.id)} style={{
                padding:"6px 14px", borderRadius:20,
                border:`1px solid ${sel===a.id ? "#357a62" : "#ddd8cf"}`,
                background: sel===a.id ? "#357a6214" : "transparent",
                fontSize:12.5, cursor:"pointer", fontFamily:"'Newsreader',serif",
                color: sel===a.id ? "#357a62" : "#807a72",
                transition:"all .15s", display:"flex", alignItems:"center", gap:5
              }}>
                <span style={{fontSize:11}}>{a.icon}</span>
                {a.label}
                {areaCount(a.id) > 0 && <span style={{fontSize:9, opacity:.5, marginLeft:2}}>{areaCount(a.id)}</span>}
              </button>
            ))}
          </div>
        </div>
      </Fade>

      {/* Emotion — only for specific areas */}
      {sel !== "general" && (
        <Fade delay={90}>
          <div style={{marginBottom:20}}>
            <span style={{fontSize:12, color:"#5a5650", display:"block", marginBottom:8}}>How does {arObj.label.toLowerCase()} feel right now?</span>
            <div style={{display:"flex", gap:4, overflowX:"auto", paddingBottom:6, WebkitOverflowScrolling:"touch"}}>
              {EGS.map(em => (
                <button key={em.key} onClick={() => upd(d => ({...d, emotion:em.key}))} style={{
                  padding:"4px 10px", borderRadius:16, whiteSpace:"nowrap", flexShrink:0,
                  border:`1px solid ${dt.emotion===em.key ? em.c : "#ddd8cf"}`,
                  fontSize:10.5, cursor:"pointer", fontFamily:"'Newsreader',serif",
                  transition:"all .2s",
                  background: dt.emotion===em.key ? em.c+"14" : "transparent",
                  color: dt.emotion===em.key ? em.c : "#807a72"
                }}>{egsShort(em.key)}</button>
              ))}
            </div>
          </div>
        </Fade>
      )}

      {/* ─── THREE TOOLS ─── */}
      <Fade delay={130}>
        <div style={{display:"flex", flexDirection:"column", gap:10, marginBottom:24}}>

          {/* Placemat */}
          <button style={S.toolCard} onClick={() => { setPmMine([]); setPmUni([]); setPmInp(""); go("placemat"); }}>
            <span style={{fontSize:22, color:"#9e9890", flexShrink:0, width:28, textAlign:"center"}}>☐</span>
            <div>
              <div style={{fontSize:14, fontWeight:500, color:"#1e1c1a"}}>Today's Placemat</div>
              <div style={{fontSize:12, color:"#8a857e"}}>Your side and the universe's side. Plan your day with less resistance.</div>
            </div>
          </button>

          {/* Focus Wheel */}
          <button style={S.toolCard} onClick={() => go("focus")}>
            <span style={{fontSize:22, color:"#9e9890", flexShrink:0, width:28, textAlign:"center"}}>◎</span>
            <div>
              <div style={{fontSize:14, fontWeight:500, color:"#1e1c1a"}}>Focus Wheel</div>
              <div style={{fontSize:12, color:"#8a857e"}}>Place your desire at center. Build momentum with comfortable thoughts.{dt.currentWheel.center ? ` Active: "${dt.currentWheel.center}"` : ""}</div>
            </div>
          </button>

          {/* Chat */}
          <button style={S.toolCard} onClick={() => setShowChat(true)}>
            <span style={{fontSize:22, color:"#9e9890", flexShrink:0, width:28, textAlign:"center"}}>◌</span>
            <div>
              <div style={{fontSize:14, fontWeight:500, color:"#1e1c1a"}}>Work this with me</div>
              <div style={{fontSize:12, color:"#8a857e"}}>Talk it through with a coach who knows the teachings.{(dt.chats||[]).length>0?` ${(dt.chats||[]).length} past sessions.`:""}</div>
            </div>
          </button>

        </div>
      </Fade>

      {/* History links */}
      <Fade delay={200}>
        <div style={{display:"flex", justifyContent:"center", gap:7, flexWrap:"wrap", marginBottom:16}}>
          {dt.focusWheels.length > 0 && <button style={S.tBtn} onClick={() => go("wheellog")}>Past Wheels ({dt.focusWheels.length})</button>}
          {(dt.chats||[]).length > 0 && <button style={S.tBtn} onClick={() => go("chatlog")}>Past Sessions ({(dt.chats||[]).length})</button>}
          {placemats.length > 0 && <button style={S.tBtn} onClick={() => go("pmlog")}>Past Placemats ({placemats.length})</button>}
        </div>
      </Fade>

      {/* Footer */}
      <Fade delay={260}>
        <div style={{display:"flex", justifyContent:"center", gap:8, flexWrap:"wrap"}}>
          <button style={S.ghost} onClick={() => {setMStep(1);setMFeel(null);setMReach(null);go("mirror")}}>← Mirror check</button>
          <button style={{...S.ghost, color:"#357a62"}} onClick={exportCSV}>↓ CSV</button>
          <button style={S.ghost} onClick={() => {setUrlInp(sheetUrl);setApiKeyInp(apiKey);setShowSettings(true)}}>⚙ Settings{sheetUrl?" ✓":""}</button>
        </div>
      </Fade>
      {syncStatus && <div style={{textAlign:"center",padding:"6px 0",fontSize:11,color:syncStatus==="ok"?"#357a62":"#8b5c5c"}}>{syncStatus==="ok"?"✓ Synced":"✗ Sync failed"}</div>}
    </div>
  );

  /* ═══════ RENDER: PLACEMAT ═══════ */
  const renderPlacemat = () => (
    <div style={S.page}>
      <Fade>
        <button style={S.back} onClick={() => go("main")}>← Back</button>
        <div style={S.ctr}>
          <h1 style={S.h1}>Today's Placemat</h1>
          <p style={S.sub}>Write what feels urgent. Be realistic about what you'll actually do. Move everything else to the universe.</p>
        </div>
      </Fade>
      <Fade delay={100}>
        <div style={{marginBottom:16}}>
          <div style={{display:"flex", gap:6, marginBottom:8}}>
            <button onClick={()=>setPmSide("mine")} style={{padding:"5px 14px",borderRadius:18,border:"1px solid",borderColor:pmSide==="mine"?"#357a62":"#ddd8cf",background:pmSide==="mine"?"#357a6214":"transparent",fontSize:11.5,fontFamily:"'Newsreader',serif",color:pmSide==="mine"?"#357a62":"#807a72",cursor:"pointer"}}>My side</button>
            <button onClick={()=>setPmSide("universe")} style={{padding:"5px 14px",borderRadius:18,border:"1px solid",borderColor:pmSide==="universe"?"#6b5b95":"#ddd8cf",background:pmSide==="universe"?"#6b5b9514":"transparent",fontSize:11.5,fontFamily:"'Newsreader',serif",color:pmSide==="universe"?"#6b5b95":"#807a72",cursor:"pointer"}}>Universe's side</button>
          </div>
          <div style={S.iRow}>
            <input style={S.ti} value={pmInp} onChange={e=>setPmInp(e.target.value)} onKeyDown={e=>e.key==="Enter"&&addPmItem()} placeholder={pmSide==="mine"?"Something I'll do today…":"Something I'd like the universe to tend to…"}/>
            <button style={{...S.plus, background:pmSide==="mine"?"#357a62":"#6b5b95"}} onClick={addPmItem}>+</button>
          </div>
        </div>
        <div style={{display:"grid", gridTemplateColumns:"1fr 1fr", gap:14, marginBottom:20}}>
          <div>
            <div style={{fontSize:10.5, fontWeight:600, textTransform:"uppercase", letterSpacing:".06em", color:"#357a62", marginBottom:8, display:"flex", alignItems:"center", gap:6}}>
              <span style={{width:7, height:7, borderRadius:"50%", background:"#357a62"}}/>
              I'll do today
              {pmMine.length > 0 && <span style={{fontWeight:400, opacity:.6, marginLeft:"auto"}}>{pmMine.length}</span>}
            </div>
            <div style={{display:"flex", flexDirection:"column", gap:4, minHeight:60}}>
              {pmMine.map((item, i) => (
                <div key={i} style={{fontSize:12.5, lineHeight:1.4, padding:"6px 8px", background:"#f2f7f4", borderRadius:6, borderLeft:"2px solid #357a62", display:"flex", alignItems:"flex-start", gap:4}}>
                  <span style={{flex:1}}>{item}</span>
                  <button onClick={()=>movePmItem("mine",i)} title="Move to universe" style={{background:"none",border:"none",fontSize:11,color:"#6b5b95",cursor:"pointer",padding:"0 2px",flexShrink:0}}>→</button>
                  <button onClick={()=>rmPmItem("mine",i)} style={{background:"none",border:"none",fontSize:13,color:"#c5c0b8",cursor:"pointer",padding:"0 2px",lineHeight:1,flexShrink:0}}>×</button>
                </div>
              ))}
              {pmMine.length === 0 && <p style={{fontSize:11, color:"#b5b0a8", fontStyle:"italic", padding:"8px 0"}}>What will you do today?</p>}
            </div>
          </div>
          <div>
            <div style={{fontSize:10.5, fontWeight:600, textTransform:"uppercase", letterSpacing:".06em", color:"#6b5b95", marginBottom:8, display:"flex", alignItems:"center", gap:6}}>
              <span style={{width:7, height:7, borderRadius:"50%", background:"#6b5b95"}}/>
              Universe's side
              {pmUni.length > 0 && <span style={{fontWeight:400, opacity:.6, marginLeft:"auto"}}>{pmUni.length}</span>}
            </div>
            <div style={{display:"flex", flexDirection:"column", gap:4, minHeight:60}}>
              {pmUni.map((item, i) => (
                <div key={i} style={{fontSize:12.5, lineHeight:1.4, padding:"6px 8px", background:"#f3f0f7", borderRadius:6, borderLeft:"2px solid #6b5b95", display:"flex", alignItems:"flex-start", gap:4}}>
                  <span style={{flex:1}}>{item}</span>
                  <button onClick={()=>movePmItem("universe",i)} title="Move to mine" style={{background:"none",border:"none",fontSize:11,color:"#357a62",cursor:"pointer",padding:"0 2px",flexShrink:0}}>←</button>
                  <button onClick={()=>rmPmItem("universe",i)} style={{background:"none",border:"none",fontSize:13,color:"#c5c0b8",cursor:"pointer",padding:"0 2px",lineHeight:1,flexShrink:0}}>×</button>
                </div>
              ))}
              {pmUni.length === 0 && <p style={{fontSize:11, color:"#b5b0a8", fontStyle:"italic", padding:"8px 0"}}>What would you like the universe to tend to?</p>}
            </div>
          </div>
        </div>
        {(pmMine.length > 0 || pmUni.length > 0) && (
          <div style={{textAlign:"center"}}>
            <p style={{fontFamily:"'Cormorant Garamond',serif", fontSize:14, color:"#5a5650", fontStyle:"italic", marginBottom:12}}>
              You get on with your list. The universe gets on with its.
            </p>
            <button style={S.pri} onClick={savePlacemat}>Save today's placemat</button>
          </div>
        )}
      </Fade>
    </div>
  );

  /* ═══════ RENDER: FOCUS WHEEL ═══════ */
  const renderFocus = () => {
    const sts = dt.currentWheel.statements;
    const ctr = dt.currentWheel.center;
    const done = sts.length >= 12;
    return (
      <div style={S.page}>
        <Fade>
          <button style={S.back} onClick={() => go("main")}>← Back</button>
          <div style={S.ctr}>
            <h1 style={S.h1}>Focus Wheel</h1>
            <p style={S.sub}>{sel !== "general" ? `${arObj.label} · ` : ""}Place your desire at center. Reach for thoughts that feel true.</p>
          </div>
        </Fade>
        <Fade delay={100}>
          <div style={{display:"flex", justifyContent:"center", padding:"6px 0"}}>
            <svg viewBox="0 0 400 400" style={{width:"100%", maxWidth:320}}>
              <circle cx="200" cy="200" r="188" fill="none" stroke="#ccc8c0" strokeWidth="1"/>
              <circle cx="200" cy="200" r="140" fill="none" stroke="#ccc8c0" strokeWidth=".8"/>
              {Array.from({length:12}).map((_,i) => {
                const a = (i*30-90)*(Math.PI/180);
                return <line key={i} x1={200+140*Math.cos(a)} y1={200+140*Math.sin(a)} x2={200+188*Math.cos(a)} y2={200+188*Math.sin(a)} stroke="#ccc8c0" strokeWidth=".8"/>;
              })}
              {sts.map((_,i) => {
                const s = (i*30-90)*(Math.PI/180);
                const e = ((i+1)*30-90)*(Math.PI/180);
                const op = .15+(i/12)*.4;
                return <path key={i} d={`M${200+140*Math.cos(s)} ${200+140*Math.sin(s)} L${200+188*Math.cos(s)} ${200+188*Math.sin(s)} A188 188 0 0 1 ${200+188*Math.cos(e)} ${200+188*Math.sin(e)} L${200+140*Math.cos(e)} ${200+140*Math.sin(e)} A140 140 0 0 0 ${200+140*Math.cos(s)} ${200+140*Math.sin(s)}Z`} fill={`rgba(53,122,98,${op})`} stroke="rgba(53,122,98,.25)" strokeWidth=".5"/>;
              })}
              <circle cx="200" cy="200" r="64" fill="#ece8e0" stroke="#b8b3ab" strokeWidth=".8"/>
              {ctr && <foreignObject x="140" y="170" width="120" height="60"><div style={{fontSize:12.5,color:"#1e1c1a",textAlign:"center",lineHeight:1.3,fontFamily:"'Cormorant Garamond',serif",fontWeight:600,padding:"0 4px"}}>{ctr}</div></foreignObject>}
              {Array.from({length:12}).map((_,i) => {
                const m = ((i+.5)*30-90)*(Math.PI/180);
                return <text key={i} x={200+164*Math.cos(m)} y={200+164*Math.sin(m)} textAnchor="middle" dominantBaseline="middle" fontSize="10.5" fontWeight={i<sts.length?"700":"400"} fill={i<sts.length?"#1e5040":"#b5b0a8"} fontFamily="'Newsreader',serif">{i+1}</text>;
              })}
            </svg>
          </div>
        </Fade>
        <Fade delay={170}>
          {showCP && sts.length >= 6 && !done && (
            <div style={{background:"#f6f3ee",borderRadius:12,padding:"16px 18px",marginBottom:14,border:"1px solid #e8e4dd",textAlign:"center"}}>
              <p style={{fontFamily:"'Cormorant Garamond',serif",fontSize:15,color:"#1e1c1a",marginBottom:4}}>Halfway check</p>
              <p style={{fontSize:13,color:"#5a5650",lineHeight:1.5,marginBottom:10}}>Are you still putting something down, or does it feel like something's pulling you forward?</p>
              <button style={{...S.ghost,color:"#357a62",fontSize:12}} onClick={()=>setShowCP(false)}>I feel it shifting — keep going</button>
            </div>
          )}
          {!ctr ? (
            <div style={{marginTop:4,marginBottom:12}}>
              <label style={{fontSize:13,color:"#5a5650",display:"block",marginBottom:8}}>Your desire — the center of the wheel</label>
              <div style={S.iRow}>
                <input style={S.ti} value={fCInp} onChange={e=>setFCInp(e.target.value)} onKeyDown={e=>e.key==="Enter"&&setCtr()} placeholder="I am financially free…"/>
                <button style={{...S.plus, background:"#357a62"}} onClick={setCtr}>Set</button>
              </div>
            </div>
          ) : !done ? (
            <div style={{marginTop:4,marginBottom:12}}>
              <label style={{fontSize:13,color:"#5a5650",display:"block",marginBottom:8}}>Segment {sts.length+1} of 12 — a thought that brings comfort</label>
              <div style={S.iRow}>
                <input style={S.ti} value={fInp} onChange={e=>setFInp(e.target.value)} onKeyDown={e=>e.key==="Enter"&&addFS()} placeholder="A thought that soothes…"/>
                <button style={{...S.plus, background:"#357a62"}} onClick={addFS}>+</button>
              </div>
            </div>
          ) : (
            <div style={{textAlign:"center", marginTop:4, marginBottom:12}}>
              <p style={{fontFamily:"'Cormorant Garamond',serif",fontSize:15,color:"#357a62",fontStyle:"italic",marginBottom:12}}>Your wheel is complete. How does it feel?</p>
              <div style={{display:"flex",flexDirection:"column",gap:8,alignItems:"center"}}>
                <button style={S.pri} onClick={() => completeWheel(false)}>Save and return ↗</button>
                <button style={S.sec} onClick={() => completeWheel(true)}>Start another wheel</button>
              </div>
            </div>
          )}
          {sts.length > 0 && (
            <div style={{marginTop:12,display:"flex",flexDirection:"column",gap:3}}>
              {sts.map((s,i) => (
                <div key={i} style={{display:"flex",alignItems:"flex-start",gap:9,fontSize:13,lineHeight:1.5,padding:"6px 0",borderBottom:"1px solid #eee9e2"}}>
                  <span style={{fontSize:11,color:"#1e5040",fontWeight:700,minWidth:20,paddingTop:2}}>{i+1}</span>
                  <span style={{color:"#2a2825"}}>{s}</span>
                </div>
              ))}
            </div>
          )}
          {ctr && !done && (
            <div style={{textAlign:"center", marginTop:16}}>
              <button style={{...S.ghost, fontSize:12}} onClick={resetWheel}>Save & start new wheel</button>
            </div>
          )}
        </Fade>
      </div>
    );
  };

  /* ═══════ RENDER: LOGS ═══════ */
  const renderWheelLog = () => (
    <div style={S.page}>
      <Fade>
        <button style={S.back} onClick={() => go("main")}>← Back</button>
        <div style={S.ctr}><h1 style={S.h1}>Past Focus Wheels{sel !== "general" ? ` · ${arObj.label}` : ""}</h1></div>
      </Fade>
      <Fade delay={100}>
        <div style={{maxWidth:480, margin:"0 auto"}}>
          {dt.focusWheels.length === 0 ? <p style={S.empty}>No completed wheels yet.</p> : dt.focusWheels.map((fw,i) => (
            <div key={i} style={S.logCard}>
              <div style={{display:"flex",justifyContent:"space-between",marginBottom:8}}>
                <span style={{fontSize:11,color:"#8a857e"}}>{fw.date} {fw.time}</span>
                <span style={{fontSize:9.5,color:"#357a62",textTransform:"uppercase",letterSpacing:".06em"}}>{fw.statements.length} seg</span>
              </div>
              <div style={{fontSize:13,fontWeight:500,marginBottom:6,color:"#1e1c1a"}}>Center: {fw.center}</div>
              {fw.statements.map((s,j) => (
                <div key={j} style={{fontSize:13,lineHeight:1.5,color:"#3a3733",paddingLeft:8,marginBottom:2}}>
                  <span style={{color:"#357a62",fontWeight:500,marginRight:6}}>{j+1}.</span>{s}
                </div>
              ))}
            </div>
          ))}
        </div>
      </Fade>
    </div>
  );

  const renderChatLog = () => (
    <div style={S.page}>
      <Fade>
        <button style={S.back} onClick={() => go("main")}>← Back</button>
        <div style={S.ctr}><h1 style={S.h1}>Past Sessions{sel !== "general" ? ` · ${arObj.label}` : ""}</h1></div>
      </Fade>
      <Fade delay={100}>
        <div style={{maxWidth:480, margin:"0 auto"}}>
          {(dt.chats||[]).length === 0 ? <p style={S.empty}>No coaching sessions yet.</p> : [...(dt.chats||[])].reverse().map((ch,i) => (
            <div key={i} style={S.logCard}>
              <div style={{display:"flex",justifyContent:"space-between",marginBottom:8}}>
                <span style={{fontSize:11,color:"#8a857e"}}>{ch.date}</span>
                <span style={{fontSize:9.5,color:"#357a62",textTransform:"uppercase",letterSpacing:".06em"}}>{ch.messages?.length||0} messages</span>
              </div>
              <div style={{fontSize:13,lineHeight:1.55,color:"#3a3733"}}>{ch.summary}</div>
            </div>
          ))}
        </div>
      </Fade>
    </div>
  );

  const renderPmLog = () => (
    <div style={S.page}>
      <Fade>
        <button style={S.back} onClick={() => go("main")}>← Back</button>
        <div style={S.ctr}><h1 style={S.h1}>Past Placemats</h1></div>
      </Fade>
      <Fade delay={100}>
        <div style={{maxWidth:480, margin:"0 auto"}}>
          {placemats.length === 0 ? <p style={S.empty}>No placemats yet.</p> : placemats.map((pm, i) => (
            <div key={i} style={S.logCard}>
              <div style={{display:"flex", justifyContent:"space-between", marginBottom:10}}>
                <span style={{fontSize:11, color:"#8a857e"}}>{pm.date} {pm.time}</span>
                <span style={{fontSize:9.5, color:"#357a62", textTransform:"uppercase", letterSpacing:".06em"}}>{pm.mine.length} mine · {pm.universe.length} universe</span>
              </div>
              <div style={{display:"grid", gridTemplateColumns:"1fr 1fr", gap:10}}>
                <div>
                  <div style={{fontSize:9.5, fontWeight:600, color:"#357a62", textTransform:"uppercase", letterSpacing:".05em", marginBottom:4}}>Mine</div>
                  {pm.mine.map((item, j) => <div key={j} style={{fontSize:12, lineHeight:1.4, color:"#3a3733", marginBottom:2}}>• {item}</div>)}
                </div>
                <div>
                  <div style={{fontSize:9.5, fontWeight:600, color:"#6b5b95", textTransform:"uppercase", letterSpacing:".05em", marginBottom:4}}>Universe</div>
                  {pm.universe.map((item, j) => <div key={j} style={{fontSize:12, lineHeight:1.4, color:"#3a3733", marginBottom:2}}>• {item}</div>)}
                </div>
              </div>
            </div>
          ))}
        </div>
      </Fade>
    </div>
  );

  /* ═══════ ROUTER ═══════ */
  return (
    <div style={S.app}>
      {showSettings && renderSettings()}
      {showChat && <ChatPanel areaId={sel} areaLabel={arObj.label} areaData={dt} apiKey={apiKey} onClose={()=>setShowChat(false)} onSave={handleChatSave} logToSheet={logToSheet} mirrorFeel={mFeel} mirrorReach={mReach}/>}
      <ReminderStrip/>
      <div style={{padding:"16px 20px 72px"}}>
        {view === "mirror" && renderMirror()}
        {view === "main" && renderMain()}
        {view === "placemat" && renderPlacemat()}
        {view === "focus" && renderFocus()}
        {view === "wheellog" && renderWheelLog()}
        {view === "chatlog" && renderChatLog()}
        {view === "pmlog" && renderPmLog()}
      </div>
    </div>
  );
}

/* ═══════ STYLES ═══════ */
const S = {
  app: {fontFamily:"'Newsreader',Georgia,serif", background:"#faf8f3", minHeight:"100vh", color:"#2a2825", maxWidth:700, margin:"0 auto"},
  mirrorW: {display:"flex", flexDirection:"column", alignItems:"center", justifyContent:"center", minHeight:"80vh", textAlign:"center"},
  mirrorH: {fontFamily:"'Cormorant Garamond',serif", fontSize:30, fontWeight:400, margin:"0 0 12px", letterSpacing:"-.03em", color:"#1e1c1a"},
  mirrorS: {fontSize:15, color:"#5a5650", lineHeight:1.6, margin:"0 0 32px"},
  scE: {fontSize:9.5, textTransform:"uppercase", letterSpacing:".1em", color:"#9e9890"},
  mirrorHint: {fontSize:15, color:"#8a857e", marginTop:36, fontStyle:"italic", fontFamily:"'Cormorant Garamond',serif"},
  page: {paddingTop:4},
  ctr: {textAlign:"center", marginBottom:20},
  h1: {fontFamily:"'Cormorant Garamond',serif", fontSize:25, fontWeight:400, margin:"0 0 6px", letterSpacing:"-.02em", color:"#1e1c1a"},
  sub: {fontSize:14, color:"#5a5650", lineHeight:1.6, margin:0},
  back: {background:"none", border:"none", color:"#5a5650", fontSize:13, cursor:"pointer", fontFamily:"'Newsreader',serif", padding:"4px 0", marginBottom:16},
  ghost: {display:"block", margin:"0 auto", background:"none", border:"none", color:"#8a857e", fontSize:13, cursor:"pointer", fontFamily:"'Newsreader',serif", padding:8},
  empty: {fontSize:14.5, color:"#8a857e", fontStyle:"italic", textAlign:"center", padding:"32px 0", fontFamily:"'Cormorant Garamond',serif"},
  pri: {padding:"10px 22px", border:"none", borderRadius:9, background:"#357a62", color:"#fff", fontSize:13, cursor:"pointer", fontFamily:"'Newsreader',serif", transition:"all .2s"},
  sec: {padding:"10px 22px", border:"1px solid #c5c0b8", borderRadius:9, background:"transparent", color:"#3a3733", fontSize:13, cursor:"pointer", fontFamily:"'Newsreader',serif"},
  dGrid: {display:"grid", gridTemplateColumns:"repeat(2,1fr)", gap:11, marginBottom:20},
  toolCard: {display:"flex", alignItems:"flex-start", gap:14, padding:"18px 18px", background:"#fff", border:"1px solid #e8e4dd", borderRadius:12, cursor:"pointer", fontFamily:"'Newsreader',serif", textAlign:"left", transition:"all .2s", boxShadow:"0 1px 8px rgba(0,0,0,.04)", width:"100%"},
  tBtn: {padding:"8px 16px", border:"1px solid #ddd8cf", borderRadius:8, background:"#fff", fontSize:12, cursor:"pointer", fontFamily:"'Newsreader',serif", color:"#3a3733"},
  logCard: {background:"#fff", borderRadius:11, border:"1px solid #e8e4dd", padding:"16px 18px", marginBottom:9, boxShadow:"0 1px 6px rgba(0,0,0,.03)"},
  iRow: {display:"flex", gap:6},
  ti: {flex:1, padding:"8px 10px", border:"1px solid #ddd8cf", borderRadius:7, fontSize:13, fontFamily:"'Newsreader',serif", background:"#fff", color:"#2a2825", boxSizing:"border-box"},
  plus: {padding:"7px 13px", border:"none", borderRadius:7, color:"#fff", fontSize:16, cursor:"pointer", fontFamily:"sans-serif", lineHeight:1},
  dCard: {position:"relative", background:"#fff", border:"1px solid #e8e4dd", borderRadius:12, padding:"20px 14px 16px", cursor:"pointer", textAlign:"left", fontFamily:"'Newsreader',serif", transition:"all .25s", boxShadow:"0 1px 10px rgba(0,0,0,.05)", display:"flex", flexDirection:"column", gap:4, width:"100%"},
  actDot: {position:"absolute", top:10, right:10, width:5, height:5, borderRadius:"50%", background:"#357a62"},
  dTop: {display:"flex", alignItems:"center", gap:8},
  dIcon: {fontSize:16, color:"#9e9890"},
  dLabel: {fontSize:14, fontWeight:500, color:"#1e1c1a"},
  dEm: {fontSize:11.5, marginLeft:24},
};

ReactDOM.createRoot(document.getElementById("root")).render(<LifeMirror/>);
</script>
</body>
</html>
